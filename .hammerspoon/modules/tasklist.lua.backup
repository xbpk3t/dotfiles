-- å¤šä»»åŠ¡ Hammerspoon menubar ç®¡ç†å™¨
local menubar = hs.menubar.new()
local tasks = {}  -- å­˜å‚¨æ‰€æœ‰ä»»åŠ¡
local currentTaskIndex = nil  -- å½“å‰é€‰ä¸­çš„ä»»åŠ¡ç´¢å¼•
local maxTasks = 20  -- æœ€å¤§ä»»åŠ¡æ•°é‡
local shortcutRunning = false  -- Shortcutæ˜¯å¦æ­£åœ¨è¿è¡Œ

-- æ•°æ®æŒä¹…åŒ–æ–‡ä»¶è·¯å¾„
local dataFile = hs.configdir .. "/tasks_data.json"

-- è·å–å½“å‰æ—¥æœŸå­—ç¬¦ä¸²
local function getCurrentDate()
    return os.date("%Y-%m-%d")
end

-- è·å–å½“å‰æ—¶é—´å­—ç¬¦ä¸²
local function getCurrentTime()
    return os.date("%H:%M")
end

-- éªŒè¯æ—¥æœŸæ ¼å¼
local function isValidDate(dateStr)
    if not dateStr then return false end
    local year, month, day = dateStr:match("^(%d%d%d%d)-(%d%d)-(%d%d)$")
    if not year then return false end
    year, month, day = tonumber(year), tonumber(month), tonumber(day)
    if not year or not month or not day then return false end
    if month < 1 or month > 12 then return false end
    if day < 1 or day > 31 then return false end
    return true
end

-- è®¡ç®—è¯„åˆ† (1-5åˆ†)
local function calculateScore(task)
    if not task.isDone or task.estimatedTime == 0 then
        return 0
    end

    local timeRatio = task.actualTime / (task.estimatedTime * 40) -- 40åˆ†é’Ÿä¸ºä¸€ä¸ªå•ä½
    local baseScore = 3 -- åŸºç¡€åˆ†æ•°

    -- æ ¹æ®æ—¶é—´æ¯”ä¾‹è°ƒæ•´åˆ†æ•°
    if timeRatio <= 0.8 then
        baseScore = baseScore + 1.5  -- æå‰å®Œæˆ
    elseif timeRatio <= 1.0 then
        baseScore = baseScore + 0.5  -- æŒ‰æ—¶å®Œæˆ
    elseif timeRatio <= 1.2 then
        baseScore = baseScore - 0.5  -- è½»å¾®è¶…æ—¶
    else
        baseScore = baseScore - 1.5  -- ä¸¥é‡è¶…æ—¶
    end

    -- ç¡®ä¿åˆ†æ•°åœ¨1-5èŒƒå›´å†…
    return math.max(1, math.min(5, math.floor(baseScore + 0.5)))
end

-- å¯åŠ¨Shortcutå€’è®¡æ—¶
local function startShortcutTimer(minutes)
    if shortcutRunning then
        hs.notify.new({
            title = "å€’è®¡æ—¶æé†’",
            informativeText = "å€’è®¡æ—¶å·²åœ¨è¿è¡Œä¸­",
            withdrawAfter = 3
        }):send()
        return
    end

    shortcutRunning = true

    -- æ ¹æ® Shortcut çš„è¦æ±‚ï¼Œä½¿ç”¨æ­£ç¡®çš„å‚æ•°æ ¼å¼
    -- æ ¼å¼: "timer\n<seconds>" æˆ– "alarm\n<time>\n[name]"
    local seconds = minutes * 60
    local input = string.format("timer\n%d", seconds)

    -- ä½¿ç”¨ shell å‘½ä»¤è°ƒç”¨ shortcutsï¼Œè¿™æ ·å¯ä»¥ä¼ é€’å‚æ•°
    local cmd = string.format('shortcuts run "Shrieking Chimes" --input-text "%s"', input)

    hs.task.new("/bin/sh", function(exitCode, stdOut, stdErr)
        shortcutRunning = false
        if exitCode == 0 then
            hs.notify.new({
                title = "å€’è®¡æ—¶å¯åŠ¨",
                informativeText = "å·²å¯åŠ¨ " .. minutes .. " åˆ†é’Ÿå€’è®¡æ—¶",
                withdrawAfter = 3
            }):send()
        else
            -- å¦‚æœ shell å‘½ä»¤å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨ AppleScript
            local script = string.format([[
                tell application "Shortcuts"
                    run shortcut "Shrieking Chimes" with input "%s"
                end tell
            ]], input)

            hs.osascript.applescript(script, function(success, result, descriptor)
                if success then
                    hs.notify.new({
                        title = "å€’è®¡æ—¶å¯åŠ¨",
                        informativeText = "å·²å¯åŠ¨ " .. minutes .. " åˆ†é’Ÿå€’è®¡æ—¶ (AppleScript)",
                        withdrawAfter = 3
                    }):send()
                else
                    hs.notify.new({
                        title = "å€’è®¡æ—¶é”™è¯¯",
                        informativeText = "æ— æ³•å¯åŠ¨ Shrieking Chimes: " .. tostring(stdErr or result),
                        withdrawAfter = 5
                    }):send()
                end
            end)
        end
    end, {"-c", cmd}):start()
end

-- æµ‹è¯• Shortcut è°ƒç”¨çš„å‡½æ•°
local function testShortcut()
    hs.notify.new({
        title = "æµ‹è¯•å¼€å§‹",
        informativeText = "æ­£åœ¨æµ‹è¯• Shrieking Chimes Shortcut (1åˆ†é’Ÿ)...",
        withdrawAfter = 3
    }):send()

    print("å¼€å§‹æµ‹è¯• Shortcut è°ƒç”¨...")
    startShortcutTimer(1) -- æµ‹è¯•1åˆ†é’Ÿå€’è®¡æ—¶
end

-- åŠ è½½ä»»åŠ¡æ•°æ®
local function loadTasks()
    local file = io.open(dataFile, "r")
    if file then
        local content = file:read("*all")
        file:close()
        local success, data = pcall(hs.json.decode, content)
        if success and data then
            tasks = data.tasks or {}
            currentTaskIndex = data.currentTaskIndex
            -- å…¼å®¹æ—§æ•°æ®ï¼Œä¸ºæ²¡æœ‰æ–°å­—æ®µçš„ä»»åŠ¡æ·»åŠ é»˜è®¤å€¼
            for i, task in ipairs(tasks) do
                if type(task) == "string" then
                    tasks[i] = {
                        name = task,
                        date = getCurrentDate(),
                        estimatedTime = 1, -- é»˜è®¤1ä¸ªE1f
                        actualTime = 0,
                        isDone = false,
                        deletedAt = nil,
                        startTime = nil
                    }
                else
                    task.date = task.date or getCurrentDate()
                    task.estimatedTime = task.estimatedTime or 1
                    task.actualTime = task.actualTime or 0
                    task.isDone = task.isDone or false
                    task.deletedAt = task.deletedAt or nil
                    task.startTime = task.startTime or nil
                end
            end
        end
    end
end

-- ä¿å­˜ä»»åŠ¡æ•°æ®
local function saveTasks()
    local data = {
        tasks = tasks,
        currentTaskIndex = currentTaskIndex
    }
    local file = io.open(dataFile, "w")
    if file then
        file:write(hs.json.encode(data))
        file:close()
    end
end

-- ä»»åŠ¡æ’åºå‡½æ•° (æŒ‰æ—¥æœŸ)
local function sortTasks()
    table.sort(tasks, function(a, b)
        if a.isDone ~= b.isDone then
            return not a.isDone  -- æœªå®Œæˆçš„ä»»åŠ¡æ’åœ¨å‰é¢
        end
        return a.date < b.date
    end)
end

-- è·å–æ´»è·ƒä»»åŠ¡ï¼ˆæœªå®Œæˆçš„ä»»åŠ¡ï¼‰
local function getActiveTasks()
    local activeTasks = {}
    for i, task in ipairs(tasks) do
        if not task.isDone then
            table.insert(activeTasks, {task = task, index = i})
        end
    end
    return activeTasks
end

-- æ›´æ–°èœå•æ æ˜¾ç¤º
local function updateMenubar()
    if menubar then
        local displayText = "æ— ä»»åŠ¡"
        if currentTaskIndex and tasks[currentTaskIndex] and not tasks[currentTaskIndex].isDone then
            local task = tasks[currentTaskIndex]

            -- å¢åŠ æ˜¾ç¤ºé•¿åº¦
            local maxLength = 50
            local taskName = task.name

            -- ç®€å•æˆªå–ï¼Œé¿å…å¤æ‚çš„å­—ç¬¦å¤„ç†
            if string.len(taskName) > maxLength then
                taskName = string.sub(taskName, 1, maxLength - 3) .. "..."
            end

            displayText = taskName
        end

        -- ä½¿ç”¨æ›´å°çš„å­—ä½“
        local styledText = hs.styledtext.new(displayText, {
            font = { name = "Helvetica", size = 12 }
        })
        menubar:setTitle(styledText)
    end
end

-- å¯åŠ¨ä»»åŠ¡
local function startTask()
    if currentTaskIndex and tasks[currentTaskIndex] and not tasks[currentTaskIndex].startTime then
        tasks[currentTaskIndex].startTime = os.time()
        saveTasks()

        -- å¯åŠ¨Shortcutå€’è®¡æ—¶
        local totalMinutes = tasks[currentTaskIndex].estimatedTime * 40
        startShortcutTimer(totalMinutes)

        hs.notify.new({
            title = "ä»»åŠ¡å¼€å§‹",
            informativeText = "ä»»åŠ¡ \"" .. tasks[currentTaskIndex].name .. "\" å·²å¼€å§‹",
            withdrawAfter = 3
        }):send()
    end
end

-- åœæ­¢ä»»åŠ¡å¹¶è®°å½•å®é™…æ—¶é—´
local function stopTask()
    if currentTaskIndex and tasks[currentTaskIndex] and tasks[currentTaskIndex].startTime then
        local elapsed = os.time() - tasks[currentTaskIndex].startTime
        tasks[currentTaskIndex].actualTime = math.floor(elapsed / 60) -- è½¬æ¢ä¸ºåˆ†é’Ÿ
        saveTasks()
    end
end

-- æ·»åŠ æ–°ä»»åŠ¡ï¼ˆåˆ†æ­¥å¯¹è¯æ¡†ï¼‰
local function addTask()
    local activeTasks = getActiveTasks()
    if #activeTasks >= maxTasks then
        hs.notify.new({
            title = "ä»»åŠ¡ç®¡ç†å™¨",
            informativeText = "æ´»è·ƒä»»åŠ¡æ•°é‡å·²è¾¾ä¸Šé™ (" .. maxTasks .. ")",
            withdrawAfter = 5
        }):send()
        return
    end

    -- ç¬¬ä¸€æ­¥ï¼šè·å–ä»»åŠ¡åç§°
    local button, taskName = hs.dialog.textPrompt(
        "æ·»åŠ æ–°ä»»åŠ¡ - æ­¥éª¤ 1/3",
        "è¯·è¾“å…¥ä»»åŠ¡åç§°:",
        "",
        "ä¸‹ä¸€æ­¥",
        "å–æ¶ˆ"
    )
    if button ~= "ä¸‹ä¸€æ­¥" or not taskName or taskName == "" then
        return
    end

    -- ç¬¬äºŒæ­¥ï¼šè·å–æ—¥æœŸ
    local button2, dateStr = hs.dialog.textPrompt(
        "æ·»åŠ æ–°ä»»åŠ¡ - æ­¥éª¤ 2/3",
        "è¯·è¾“å…¥æ—¥æœŸ (æ ¼å¼: YYYY-MM-DD):",
        getCurrentDate(),
        "ä¸‹ä¸€æ­¥",
        "å–æ¶ˆ"
    )
    if button2 ~= "ä¸‹ä¸€æ­¥" then
        return
    end

    if not isValidDate(dateStr) then
        hs.notify.new({
            title = "è¾“å…¥é”™è¯¯",
            informativeText = "æ—¥æœŸæ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨ YYYY-MM-DD æ ¼å¼",
            withdrawAfter = 5
        }):send()
        return
    end

    -- ç¬¬ä¸‰æ­¥ï¼šè·å–é¢„è®¡è€—æ—¶
    local button3, estimatedStr = hs.dialog.textPrompt(
        "æ·»åŠ æ–°ä»»åŠ¡ - æ­¥éª¤ 3/3",
        "è¯·è¾“å…¥é¢„è®¡è€—æ—¶ (å‡ ä¸ªE1fï¼Œæ¯ä¸ªE1f=40åˆ†é’Ÿ):",
        "1",
        "å®Œæˆ",
        "å–æ¶ˆ"
    )
    if button3 ~= "å®Œæˆ" then
        return
    end

    local estimatedTime = tonumber(estimatedStr) or 1
    if estimatedTime < 1 then
        estimatedTime = 1
    end

    -- åˆ›å»ºæ–°ä»»åŠ¡
    local newTask = {
        name = taskName,
        date = dateStr,
        estimatedTime = estimatedTime,
        actualTime = 0,
        isDone = false,
        deletedAt = nil,
        startTime = nil
    }

    table.insert(tasks, newTask)
    sortTasks()

    -- æ‰¾åˆ°æ–°ä»»åŠ¡çš„ç´¢å¼•å¹¶è®¾ä¸ºå½“å‰ä»»åŠ¡
    for i, task in ipairs(tasks) do
        if task == newTask then
            currentTaskIndex = i
            break
        end
    end

    -- ç«‹å³å¯åŠ¨ä»»åŠ¡
    startTask()

    -- å¯åŠ¨å¯¹åº”çš„å€’è®¡æ—¶
    local countdownMinutes = calculateCountdownTime(newTask)
    startShortcutTimer(countdownMinutes)

    updateMenubar()
    saveTasks()

    hs.notify.new({
        title = "ä»»åŠ¡ç®¡ç†å™¨",
        informativeText = "ä»»åŠ¡å·²æ·»åŠ å¹¶å¼€å§‹è®¡æ—¶ (å€’è®¡æ—¶: " .. countdownMinutes .. "åˆ†é’Ÿ)",
        withdrawAfter = 3
    }):send()
end

-- ç¼–è¾‘ä»»åŠ¡ï¼ˆåˆ†æ­¥å¯¹è¯æ¡†ï¼‰
local function editTask(index)
    if not tasks[index] or tasks[index].isDone then return end

    local task = tasks[index]

    -- ç¬¬ä¸€æ­¥ï¼šç¼–è¾‘ä»»åŠ¡åç§°
    local button, newName = hs.dialog.textPrompt(
        "ç¼–è¾‘ä»»åŠ¡ - æ­¥éª¤ 1/3",
        "ä¿®æ”¹ä»»åŠ¡åç§°:",
        task.name,
        "ä¸‹ä¸€æ­¥",
        "å–æ¶ˆ"
    )
    if button ~= "ä¸‹ä¸€æ­¥" then return end

    if not newName or newName == "" then
        hs.notify.new({
            title = "è¾“å…¥é”™è¯¯",
            informativeText = "ä»»åŠ¡åç§°ä¸èƒ½ä¸ºç©º",
            withdrawAfter = 3
        }):send()
        return
    end

    -- ç¬¬äºŒæ­¥ï¼šç¼–è¾‘æ—¥æœŸ
    local button2, newDate = hs.dialog.textPrompt(
        "ç¼–è¾‘ä»»åŠ¡ - æ­¥éª¤ 2/3",
        "ä¿®æ”¹æ—¥æœŸ (æ ¼å¼: YYYY-MM-DD):",
        task.date,
        "ä¸‹ä¸€æ­¥",
        "å–æ¶ˆ"
    )
    if button2 ~= "ä¸‹ä¸€æ­¥" then return end

    if not isValidDate(newDate) then
        hs.notify.new({
            title = "è¾“å…¥é”™è¯¯",
            informativeText = "æ—¥æœŸæ ¼å¼é”™è¯¯",
            withdrawAfter = 3
        }):send()
        return
    end

    -- ç¬¬ä¸‰æ­¥ï¼šç¼–è¾‘é¢„è®¡è€—æ—¶
    local button3, estimatedStr = hs.dialog.textPrompt(
        "ç¼–è¾‘ä»»åŠ¡ - æ­¥éª¤ 3/3",
        "ä¿®æ”¹é¢„è®¡è€—æ—¶ (å‡ ä¸ªE1f):",
        tostring(task.estimatedTime),
        "å®Œæˆ",
        "å–æ¶ˆ"
    )
    if button3 ~= "å®Œæˆ" then return end

    local newEstimatedTime = tonumber(estimatedStr) or task.estimatedTime
    if newEstimatedTime < 1 then
        newEstimatedTime = 1
    end

    -- æ›´æ–°ä»»åŠ¡
    local oldEstimatedTime = task.estimatedTime
    task.name = newName
    task.date = newDate
    task.estimatedTime = newEstimatedTime

    sortTasks()

    -- é‡æ–°æ‰¾åˆ°ä»»åŠ¡ç´¢å¼•
    local newIndex = index
    for i, t in ipairs(tasks) do
        if t == task then
            newIndex = i
            if currentTaskIndex == index then
                currentTaskIndex = i
            end
            break
        end
    end

    -- å¦‚æœè¿™æ˜¯å½“å‰ä»»åŠ¡ä¸”é¢„è®¡æ—¶é—´å‘ç”Ÿäº†å˜åŒ–ï¼Œæ›´æ–°å€’è®¡æ—¶
    if currentTaskIndex == newIndex and oldEstimatedTime ~= newEstimatedTime then
        local countdownMinutes = calculateCountdownTime(task)
        startShortcutTimer(countdownMinutes)

        hs.notify.new({
            title = "ä»»åŠ¡å·²æ›´æ–°",
            informativeText = "é¢„è®¡æ—¶é—´å·²æ›´æ–°ï¼Œå€’è®¡æ—¶é‡æ–°è®¾ç½®ä¸º " .. countdownMinutes .. " åˆ†é’Ÿ",
            withdrawAfter = 3
        }):send()
    else
        hs.notify.new({
            title = "ä»»åŠ¡ç®¡ç†å™¨",
            informativeText = "ä»»åŠ¡å·²æ›´æ–°",
            withdrawAfter = 3
        }):send()
    end

    updateMenubar()
    saveTasks()
end

-- å®Œæˆä»»åŠ¡ï¼ˆé€»è¾‘åˆ é™¤ï¼‰
local function completeTask(index)
    if not tasks[index] or tasks[index].isDone then return end

    local task = tasks[index]
    local button = hs.dialog.blockAlert(
        "å®Œæˆä»»åŠ¡",
        "ç¡®å®šè¦å®Œæˆä»»åŠ¡ \"" .. task.name .. "\" å—ï¼Ÿ",
        "å®Œæˆ",
        "å–æ¶ˆ"
    )
    if button == "å®Œæˆ" then
        stopTask()
        task.isDone = true
        task.deletedAt = getCurrentTime()

        -- å¦‚æœè¿™æ˜¯å½“å‰ä»»åŠ¡ï¼Œæ¸…é™¤å½“å‰ä»»åŠ¡ç´¢å¼•
        if currentTaskIndex == index then
            currentTaskIndex = nil
            -- å°è¯•é€‰æ‹©ä¸‹ä¸€ä¸ªæ´»è·ƒä»»åŠ¡
            local activeTasks = getActiveTasks()
            if #activeTasks > 0 then
                for i, activeTask in ipairs(activeTasks) do
                    if activeTask.index ~= index then
                        currentTaskIndex = activeTask.index
                        break
                    end
                end
            end
        end

        updateMenubar()
        saveTasks()
        hs.notify.new({
            title = "ä»»åŠ¡å®Œæˆ",
            informativeText = "ä»»åŠ¡å·²å®Œæˆï¼è¯„åˆ†: " .. calculateScore(task) .. "/5",
            withdrawAfter = 5
        }):send()
    end
end

-- åˆ é™¤ä»»åŠ¡ï¼ˆçœŸåˆ é™¤ï¼‰
local function deleteTask(index)
    if not tasks[index] then return end

    local task = tasks[index]
    local button = hs.dialog.blockAlert(
        "åˆ é™¤ä»»åŠ¡",
        "ç¡®å®šè¦åˆ é™¤ä»»åŠ¡ \"" .. task.name .. "\" å—ï¼Ÿ\næ³¨æ„ï¼šæ­¤æ“ä½œä¸å¯æ¢å¤ï¼",
        "åˆ é™¤",
        "å–æ¶ˆ"
    )
    if button == "åˆ é™¤" then
        -- å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰ä»»åŠ¡ï¼Œåœæ­¢ä»»åŠ¡
        if currentTaskIndex == index then
            stopTask()
            currentTaskIndex = nil
        elseif currentTaskIndex and currentTaskIndex > index then
            currentTaskIndex = currentTaskIndex - 1
        end

        table.remove(tasks, index)

        -- å°è¯•é€‰æ‹©ä¸‹ä¸€ä¸ªæ´»è·ƒä»»åŠ¡
        if not currentTaskIndex then
            local activeTasks = getActiveTasks()
            if #activeTasks > 0 then
                currentTaskIndex = activeTasks[1].index
            end
        end

        updateMenubar()
        saveTasks()
        hs.notify.new({
            title = "ä»»åŠ¡ç®¡ç†å™¨",
            informativeText = "ä»»åŠ¡å·²åˆ é™¤",
            withdrawAfter = 3
        }):send()
    end
end

-- é€‰æ‹©ä»»åŠ¡ä½œä¸ºå½“å‰ä»»åŠ¡
local function selectTask(index)
    if not tasks[index] or tasks[index].isDone then return end

    -- å¦‚æœæœ‰æ­£åœ¨è¿›è¡Œçš„ä»»åŠ¡ï¼Œåœæ­¢ä»»åŠ¡
    if currentTaskIndex and tasks[currentTaskIndex] and not tasks[currentTaskIndex].isDone then
        stopTask()
    end

    currentTaskIndex = index
    startTask()

    -- è®¡ç®—å¹¶å¯åŠ¨å¯¹åº”çš„å€’è®¡æ—¶
    local countdownMinutes = calculateCountdownTime(tasks[index])
    startShortcutTimer(countdownMinutes)

    updateMenubar()
    saveTasks()

    hs.notify.new({
        title = "å½“å‰ä»»åŠ¡",
        informativeText = "å·²è®¾ç½®: " .. tasks[index].name .. " (å€’è®¡æ—¶: " .. countdownMinutes .. "åˆ†é’Ÿ)",
        withdrawAfter = 3
    }):send()
end

-- è®¡ç®—å½“å‰ä»»åŠ¡åº”è¯¥å¯åŠ¨çš„å€’è®¡æ—¶æ—¶é—´
local function calculateCountdownTime(task)
    if not task or not task.startTime then
        return task.estimatedTime * 40 -- å¦‚æœæ²¡æœ‰å¼€å§‹æ—¶é—´ï¼Œè¿”å›å®Œæ•´çš„é¢„è®¡æ—¶é—´
    end

    local elapsed = os.time() - task.startTime
    local elapsedMinutes = math.floor(elapsed / 60)
    local plannedMinutes = task.estimatedTime * 40

    if elapsedMinutes < plannedMinutes then
        -- AD < PD: countdown = PD - AD
        return plannedMinutes - elapsedMinutes
    else
        -- AD >= PD: è‡ªåŠ¨ç»­æœŸï¼Œé‡ç½®ä¸ºä¸€ä¸ªE1f (40åˆ†é’Ÿ)
        return 40
    end
end

-- è‡ªåŠ¨ç»­æœŸå½“å‰ä»»åŠ¡
local function autoExtendCurrentTask()
    if not currentTaskIndex or not tasks[currentTaskIndex] or tasks[currentTaskIndex].isDone then
        return
    end

    local task = tasks[currentTaskIndex]
    if not task.startTime then
        return
    end

    local elapsed = os.time() - task.startTime
    local elapsedMinutes = math.floor(elapsed / 60)
    local plannedMinutes = task.estimatedTime * 40

    if elapsedMinutes >= plannedMinutes then
        -- è¶…æ—¶äº†ï¼Œè‡ªåŠ¨ç»­æœŸ
        task.actualTime = elapsedMinutes -- æ›´æ–°å®é™…è€—æ—¶

        -- å¯åŠ¨æ–°çš„40åˆ†é’Ÿå€’è®¡æ—¶
        startShortcutTimer(40)

        hs.notify.new({
            title = "ä»»åŠ¡è‡ªåŠ¨ç»­æœŸ",
            informativeText = "ä»»åŠ¡å·²è¶…æ—¶ï¼Œè‡ªåŠ¨ç»­æœŸ40åˆ†é’Ÿ",
            withdrawAfter = 3
        }):send()

        saveTasks()
    end
end

-- å¯¼å‡ºæŸæ—¥å·²å®Œæˆä»»åŠ¡
local function exportCompletedTasks()
    local button, dateStr = hs.dialog.textPrompt(
        "å¯¼å‡ºå·²å®Œæˆä»»åŠ¡",
        "è¯·è¾“å…¥è¦å¯¼å‡ºçš„æ—¥æœŸ (æ ¼å¼: YYYY-MM-DD):",
        getCurrentDate(),
        "å¯¼å‡º",
        "å–æ¶ˆ"
    )
    if button ~= "å¯¼å‡º" then return end

    if not isValidDate(dateStr) then
        hs.notify.new({
            title = "è¾“å…¥é”™è¯¯",
            informativeText = "æ—¥æœŸæ ¼å¼é”™è¯¯",
            withdrawAfter = 3
        }):send()
        return
    end

    local completedTasks = {}
    for _, task in ipairs(tasks) do
        if task.isDone and task.date == dateStr then
            table.insert(completedTasks, task)
        end
    end

    if #completedTasks == 0 then
        hs.notify.new({
            title = "å¯¼å‡ºç»“æœ",
            informativeText = "è¯¥æ—¥æœŸæ²¡æœ‰å·²å®Œæˆçš„ä»»åŠ¡",
            withdrawAfter = 3
        }):send()
        return
    end

    -- æŒ‰å®Œæˆæ—¶é—´æ’åº (deletedAt å‡åº)
    table.sort(completedTasks, function(a, b)
        local timeA = a.deletedAt or "0000-00-00 00:00:00"
        local timeB = b.deletedAt or "0000-00-00 00:00:00"
        return timeA < timeB
    end)

    -- ç”ŸæˆYAMLæ ¼å¼
    local yaml = "- date: " .. dateStr .. "\n  task:\n"
    for _, task in ipairs(completedTasks) do
        yaml = yaml .. "    - name: " .. task.name .. "\n"
        if task.deletedAt then
            yaml = yaml .. "      deletedAt: " .. task.deletedAt .. "\n"
        end
        if task.estimatedTime and task.estimatedTime > 0 then
            yaml = yaml .. "      PD: " .. (task.estimatedTime * 40) .. "min\n"
        end
        if task.actualTime and task.actualTime > 0 then
            yaml = yaml .. "      AD: " .. task.actualTime .. "min\n"
        end
        local score = calculateScore(task)
        if score > 0 then
            yaml = yaml .. "      score: " .. score .. "\n"
        end
        yaml = yaml .. "\n"
    end

    -- å¤åˆ¶åˆ°å‰ªè´´æ¿
    hs.pasteboard.setContents(yaml)
    hs.notify.new({
        title = "å¯¼å‡ºå®Œæˆ",
        informativeText = "å·²å¯¼å‡º " .. #completedTasks .. " ä¸ªä»»åŠ¡åˆ°å‰ªè´´æ¿",
        withdrawAfter = 5
    }):send()
end

-- åˆ›å»ºèœå•é¡¹
local function createMenu()
    local menu = {}
    local activeTasks = getActiveTasks()

    -- å½“å‰ä»»åŠ¡æ˜¾ç¤º
    if currentTaskIndex and tasks[currentTaskIndex] and not tasks[currentTaskIndex].isDone then
        local task = tasks[currentTaskIndex]

        table.insert(menu, {
            title = "å½“å‰: " .. task.name,
            disabled = true
        })

        table.insert(menu, { title = "-" })
    end

    -- æ´»è·ƒä»»åŠ¡åˆ—è¡¨
    if #activeTasks > 0 then
        table.insert(menu, {
            title = "æ´»è·ƒä»»åŠ¡ (" .. #activeTasks .. "/" .. maxTasks .. ")",
            disabled = true
        })

        for _, activeTask in ipairs(activeTasks) do
            local task = activeTask.task
            local index = activeTask.index
            local prefix = (index == currentTaskIndex) and "â— " or "â—‹ "

            -- å¢åŠ æ˜¾ç¤ºé•¿åº¦
            local maxLength = 60  -- è¿›ä¸€æ­¥å¢åŠ é•¿åº¦
            local displayTask = task.name
            if string.len(displayTask) > maxLength then
                displayTask = string.sub(displayTask, 1, maxLength - 3) .. "..."
            end

            local taskTitle = prefix .. displayTask
            if task.date ~= getCurrentDate() then
                taskTitle = taskTitle .. " (" .. task.date .. ")"
            end

            table.insert(menu, {
                title = taskTitle,
                menu = {
                    {
                        title = "é€‰ä¸ºå½“å‰ä»»åŠ¡",
                        fn = function() selectTask(index) end
                    },
                    {
                        title = "ç¼–è¾‘ä»»åŠ¡",
                        fn = function() editTask(index) end
                    },
                    {
                        title = "å®Œæˆä»»åŠ¡",
                        fn = function() completeTask(index) end
                    },
                    {
                        title = "åˆ é™¤ä»»åŠ¡",
                        fn = function() deleteTask(index) end
                    }
                }
            })
        end
        table.insert(menu, { title = "-" })
    end

    -- æ“ä½œé€‰é¡¹
    table.insert(menu, {
        title = "â• æ·»åŠ æ–°ä»»åŠ¡",
        fn = addTask
    })

    table.insert(menu, {
        title = "ğŸ“¤ å¯¼å‡ºå·²å®Œæˆä»»åŠ¡",
        fn = exportCompletedTasks
    })

    table.insert(menu, {
        title = "ğŸ§ª æµ‹è¯• Shortcut",
        fn = testShortcut
    })

    table.insert(menu, { title = "-" })

    -- æ˜¾ç¤ºå·²å®Œæˆä»»åŠ¡æ•°é‡
    local completedCount = 0
    for _, task in ipairs(tasks) do
        if task.isDone then
            completedCount = completedCount + 1
        end
    end

    if completedCount > 0 then
        table.insert(menu, {
            title = "å·²å®Œæˆä»»åŠ¡: " .. completedCount,
            disabled = true
        })
        table.insert(menu, { title = "-" })
    end

    table.insert(menu, {
        title = "é€€å‡º",
        fn = function()
            menubar:delete()
            menubar = nil
        end
    })

    return menu
end

-- è®¾ç½®èœå•
menubar:setMenu(createMenu)

-- ç‚¹å‡»èœå•æ å›¾æ ‡æ—¶å¿«é€Ÿæ·»åŠ ä»»åŠ¡
menubar:setClickCallback(function()
    addTask()
end)

-- åˆå§‹åŒ–
loadTasks()
sortTasks()
updateMenubar()

-- å¦‚æœæœ‰æ´»è·ƒä»»åŠ¡ä½†æ²¡æœ‰å½“å‰ä»»åŠ¡ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ªæ´»è·ƒä»»åŠ¡
if not currentTaskIndex then
    local activeTasks = getActiveTasks()
    if #activeTasks > 0 then
        currentTaskIndex = activeTasks[1].index
    end
end

-- å¦‚æœæœ‰å½“å‰ä»»åŠ¡ï¼Œå¯åŠ¨ä»»åŠ¡
if currentTaskIndex and tasks[currentTaskIndex] and not tasks[currentTaskIndex].isDone then
    -- å¦‚æœä»»åŠ¡è¿˜æ²¡æœ‰å¼€å§‹æ—¶é—´ï¼Œåˆ™å¯åŠ¨ä»»åŠ¡
    if not tasks[currentTaskIndex].startTime then
        startTask()
    end

    -- å¯åŠ¨å¯¹åº”çš„å€’è®¡æ—¶
    local countdownMinutes = calculateCountdownTime(tasks[currentTaskIndex])
    startShortcutTimer(countdownMinutes)
end

-- è®¾ç½®å®šæ—¶å™¨ï¼Œæ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡æ˜¯å¦éœ€è¦è‡ªåŠ¨ç»­æœŸ
local autoExtendTimer = hs.timer.new(60, function()
    autoExtendCurrentTask()
end)
autoExtendTimer:start()

hs.notify.new({
    title = "ä»»åŠ¡ç®¡ç†å™¨",
    informativeText = "å¤šä»»åŠ¡ç®¡ç†å™¨å·²å¯åŠ¨",
    withdrawAfter = 3
}):send()
