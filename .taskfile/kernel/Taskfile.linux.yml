---
version: '3'

tasks:
  # Process management tasks
  ps:
    desc: Report a snapshot of current processes
    cmd: ps aux


  #  # 优先优雅退出（推荐）
  #  kill -TERM $(lsof -ti :8080)
  #  # 仍不退出再强杀（谨慎）
  #  kill -KILL $(lsof -ti :8080)
  #  # 优雅杀（推荐）
  #  fuser -k 8080/tcp
  #  # 或者明确用 TERM
  #  fuser -k -TERM 8080/tcp
  kp:
    desc: Kill process listening on a TCP port (cross-platform)
    vars:
      port: '{{.port | default 8080}}'
      signal: '{{.signal | default "TERM"}}'
    cmds:
      - task: kp:linux
        vars: {port: "{{.port}}", signal: "{{.signal}}"}
      - task: kp:darwin
        vars: {port: "{{.port}}", signal: "{{.signal}}"}

  kp:linux:
    desc: Linux implementation (fuser)
    platforms: [linux]
    vars:
      port: '{{.port | default 8080}}'
      signal: '{{.signal | default "TERM"}}'
    preconditions:
      - sh: command -v fuser >/dev/null 2>&1
        msg: "fuser not found. Install psmisc (e.g. nix profile install nixpkgs#psmisc / add pkgs.psmisc)."
    cmds:
      # fuser 在端口空闲时会返回非 0，所以这里用 ignore_error
      - cmd: sudo fuser -k -{{.signal}} {{.port}}/tcp
        ignore_error: true
    internal: true
    silent: true
    interactive: true

  kp:darwin:
    desc: Darwin implementation (lsof)
    platforms: [darwin]
    vars:
      port: '{{.port | default 8080}}'
      signal: '{{.signal | default "TERM"}}'
    cmds:
      # 没有监听者时：lsof 退出码非 0；我们用 ignore_error + status 来避免 kill 空参数
      - cmd: sudo lsof -nP -tiTCP:{{.port}} -sTCP:LISTEN | xargs -r sudo kill -{{.signal}}
        ignore_error: true
    internal: true
    silent: true
    interactive: true


  # Network diagnostic tasks
  dig:
    desc: DNS lookup utility
    cmd: dig {{.domain}}
    vars:
      domain: "{{.domain}}"

  # File operations tasks
  create-file:
    desc: Create or overwrite a file with content
    cmd: echo "{{.content}}" > {{.filename}}
    vars:
      content: '{{.content}}'
      filename: '{{.filename | default "output.txt"}}'


  append-file:
    desc: Append content to a file
    cmd: echo "{{.content}}" >> {{.filename}}
    vars:
      content: '{{.content | default ""}}'
      filename: '{{.filename | default "output.txt"}}'


  clear-file:
    desc: Clear the contents of a file
    cmd: cat /dev/null > {{.filename}}
    vars:
      filename: '{{.filename | default "output.txt"}}'

  top-words:
    desc: Show the top 10 most frequent words in a file
    cmd: cat {{.filename}} | sort | uniq -c | sort -k1,1nr | head -10
    vars:
      filename: '{{.filename | default "output.txt"}}'

  # System performance monitoring tasks
  sar-cpu:
    desc: Monitor CPU utilization
    cmd: sar -u {{.interval}} {{.count}}
    vars:
      interval: '{{.interval | default "1"}}'
      count: '{{.count | default "5"}}'

  sar-memory:
    desc: Monitor memory utilization
    cmd: sar -r {{.interval}} {{.count}}
    vars:
      interval: '{{.interval | default "1"}}'
      count: '{{.count | default "5"}}'

  sar-network:
    desc: Monitor network device statistics
    cmd: sar -n DEV {{.interval}} {{.count}}
    vars:
      interval: '{{.interval | default "1"}}'
      count: '{{.count | default "5"}}'

  whoami:
    desc: Print the current user ID
    cmd: whoami

  # - history - Show recent commands
  # - history -20 -1 # Display the last 20 commands
  # - history 1 20 # Display the first 20 commands
  # - history 1 # Display all commands (from first to last)
  # - history 10600 # Display from n to last
  # - history -E # With timestamp format # 1  25.8.2025 09:55  touch .zshrc
  # - history -i # With timestamp format #  1  2025-08-25 09:55  touch .zshrc
  history:
    cmd: history -i ｜ grep {{.str}}

  tree:
    cmd: tree -L 1
    dir: '{{.USER_WORKING_DIR}}'
    interactive: true

#- 如果某个url需要auth才能访问，怎么在curl中添加token? # curl -H "X-Auth-Token: " url
#- "***怎么在本地执行远程 vps 上的远程脚本（curl 方式执行 shell 脚本时如何传参（不具名参数和具名参数分别怎么传参））？***" # [通过命令下载执行恶意代码](https://juejin.cn/post/6950955375931686942) 由于直接调用了bash命令，因此在远程脚本需要传递具名参数时，为了区分是bash命令的参数还是远程脚本的，可以使用--作为区分，可以理解为分割线，--前面的比如-s属于bash，后面的-x abc -y xyz属于远程脚本的参数. curl -L <url> | bash -s -- -x abc -y xyz
  curl:




  # Other commands that don't need individual tasks:
  # - alias - Create aliases for commands
  # - unalias - Remove aliases
  # - setenv - Set environment variables
  # - tar - Manipulate tar archives
  # - gzip - Compress/uncompress files
  # - zip - Package and compress files
  # - ln - Make links between files
  # - curl - Transfer data from or to a server
  # - transfer files (ffff, xxx, zzz) - File transfer utilities
  # - wget - Non-interactive network downloader
  # - rsync - Remote file synchronization
  # - scp - Secure copy files
  # - sort - Sort lines of text files
  # - uniq - Report or omit repeated lines
  # - awk - Pattern scanning and processing language
  # - read file (cat/head/tail/more/less) - File reading utilities

  # - systemctl list-unit-files | grep enable # View all auto-start items, or use systemctl list-unit-files | grep <service> to check if a specific service auto-starts

  # - open command:
  # - open -t <filename> # Open file with default editor
  # - open -e <filename> # Open file with "Text Editor"
  # - open -a <editor> <filename> # Open file with "specified application", e.g. open -a goland to open file with goland
  #
  # - Type command to check if a command is a built-in system command # type <command>
  #
  # - ip=$(ifconfig en0 | grep 'inet .*'  | sed 's/^.*inet//g' | sed 's/ netmask.*//g') && echo $ip
  # - echo -e "$(cmd)" # Use `echo -e`+double quotes to avoid special character issues (ensure special characters are not lost)
  # - echo -n # Echo without newline, use echo -n to prevent strings from being wrapped
  # - sed -n '1w <output-file>' <input-file> # Write the first line of input-file to output-file



  rename:
    desc: Rename files (and optionally directories recursively) by replacing a pattern with a new string (task rename [--recursive] <old> <new>, task rename-undo)
    cmds:
      - |
        if [ "{{.RECURSIVE}}" = "true" ]; then
          rnr regex -f -r -D -x "{{.PATTERN}}" "{{.REPLACEMENT}}" ./
        else
          rnr regex -f "{{.PATTERN}}" "{{.REPLACEMENT}}" ./*
        fi
    vars:
      PATTERN:
        sh: echo "{{.CLI_ARGS | default 'file renamed'}}" | awk '{print $1}'
      REPLACEMENT:
        sh: echo "{{.CLI_ARGS | default 'file renamed'}}" | awk '{print $2}'
      RECURSIVE:
        sh: echo "{{.CLI_ARGS}}" | grep -w -- "--recursive" > /dev/null && echo "true" || echo "false"
    silent: true

    # 回滚操作
    rename-undo:
      desc: Undo a previous rename operation using the latest dump file
      cmds:
        - |
          DUMP_FILE=$(ls -t rnr-*.json | head -n 1)
          if [ -z "$DUMP_FILE" ]; then
            echo "No dump file found for undo operation."
            exit 1
          fi
          rnr from-file -f -u "$DUMP_FILE"
      silent: true





#  用途：跟踪某个应用程序的文件访问行为。
#  分析：
#  使用 strace 工具跟踪指定应用（{{.app}}）的文件相关系统调用，结合参数（{{.args}}）。
#  过滤掉无关路径（如 /nix/store、/newroot、/proc），提取并整理访问的文件路径（去重并排序）。
#  使用场景：调试或分析程序的文件依赖，检查哪些文件被程序实际访问（例如，排查配置缺失或权限问题）。
#  示例：运行 trace-access app=notepad args="--file test.txt" 可以查看 Notepad 访问了哪些文件。
  trace-access:
    desc: "跟踪文件访问"
    vars:
      app: '{{.app}}'
      args: '{{.args | default ""}}'
    cmds:
      - strace -f -t -e trace=file {{.app}} {{.args}} | complete | grep -v -E "(/nix/store|/newroot|/proc)" | grep -o '"(/.*)"' | sort | uniq

#  用途：查看指定进程的环境变量。
#  分析：
#
#  通过读取 /proc/{{.pid}}/environ 文件，获取指定进程 ID（{{.pid}}）的环境变量，并将结果格式化（将空字符 \0 替换为换行符 \n）。
#  需要 sudo 权限以访问 /proc 下的文件。
#  使用场景：调试进程运行环境，检查环境变量是否正确设置（例如，排查 PATH 或自定义变量问题）。
#  示例：运行 penvof pid=1234 可以列出 PID 为 1234 的进程的所有环境变量。
  penvof:
    desc: "查看进程环境变量"
    vars:
      pid: '{{.pid}}'
    cmds:
      - sudo cat "/proc/{{.pid}}/environ" | tr '\0' '\n'
