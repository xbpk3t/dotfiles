---
version: "3"

vars:
  ss:
    - group: daily
      sub:
        - name: Mail
          val: yyzw@live.com
        - name: MailGoogle
          val: '{{ "IGplZmZjb3R0bHVAZ21haWwuY29t" | b64dec }}'
        - name: MailGoogleK
          val: '{{ "a2F2c2FsaWRAZ21haWwuY29t" | b64dec }}'
        - name: MailMe
          val: '{{ "bWVAbHVjYy5kZXY=" | b64dec }}'
        - name: MailNetEase
          val: '{{.MOBILE}}@163.com'
        - name: mobile
          val: '{{.MOBILE}}'
        - name: pass
          val: '{{.PASS}}'
        - name: date
          val: "{date:short}"
        - name: time
          val: "{time:short}"

    - group: markdown
      sub:
        - name: md-color
          val: '<font face="黑体" color="green" size="3">{cursor}</font>'
        - name: md-summary
          val: |
            <details>
            <summary>{cursor}</summary>

            </details>

    - group: prompts
      sub:
        - name: 3W3H
          val: |
            Why  ->  What  <->  When/where?
            How to use?
            How to implement?
            How to optimize?

            帮我结合这个 3W3H 介绍一下

            需要注意的是，并非3w3H的每个部分只有一个问题，可以有多个问题

            ---

            另外，在此之后，还需要再给我一个 YAML codeblock，格式类似



            请严格按照以下要求生成YAML格式的技术选型分析：
            1. **强制结构**
               - 包含6个固定字段：`why`、`what`、`ww`、`htu`、`hti`、`hto`
               - 字段顺序必须为：why → what → ww → htu → hti → hto
            2. **内容规范**
               - 所有字段值必须为**数组格式**
               - 每个数组项应以 问题的形式 表现，【】标注核心关键词开头（如【核心功能】），最终格式为：【核心关键字】问题？简要回答
               - 禁止出现嵌套key（如"自建中继: xxx" 改为【自建中继】xxx）
            3. **数据要求**
               - `why`：至少3条（3-5条），说明需求痛点和解决方案价值
               - `what`：至少3条（3-5条），定义核心功能和技术原理
               - `ww`：至少3条（3-5条），覆盖适用场景和限制条件
               - `htu`：至少3条（3-5条），包含配置步骤和验证方法
               - `hti`：至少3条（3-5条），实现方案和协议选择
               - `hto`：至少3条（3-5条），性能调优和安全加固
            4. **输出示例**

            - topic: 内网穿透工具
              why:
                - 【突破无公网IP限制】将本地服务（如Web应用、数据库）暴露至公网，解决企业防火墙阻隔问题
                - 【临时调试需求】支持开发者在无公网IP环境下进行微信回调、API测试
              what:
                - 【核心功能】通过中转服务器或P2P隧道，将内网端口映射到公网域名/IP
                - 【技术分类】公共服务型（Ngrok）、自建中转型（FRP）、P2P直连型（节点小宝）
              ww:
                - 【Web服务长期暴露】Cloudflare Tunnel（需结合Cloudflare CDN）
                - 【非Web协议/有公网VPS】FRP或EasyTier（暴露SSH、数据库端口）
                - 【临时暴露】Ngrok（免费版限8h会话）
              htu:
                - 【选型决策】四连问：是否Web服务？是否长期暴露？是否用Cloudflare？是否有公网VPS？
                - 【配置步骤】FRP需公网服务器部署`frps`；企业级工具（如神卓互联）需配置域名绑定+IP白名单
              hti:
                - 【协议适配】数据库服务需TCP穿透（如bore工具）；视频流媒体需UDP支持（如zrok）
              hto:
                - 【性能优化】启用TCP多路复用（FRP的`tcp_mux=true`）；调整压缩级别减少带宽占用
                - 【避坑指南】端口映射失败需检查防火墙；域名解析失败需验证DNS绑定状态
        - name: ImpossibleTriangle
          val: |
            好，那还是经典的 快好省不可能三角（性能-质量-成本）

            ---

            按照上面这个不可能三角，重新归类

            通常不可能三角，都是牺牲1个，满足2个

            ---

            先把上面的这些比较项，按照EQC进行拆分

            然后再把这些terminal按照EQ、EC、QC进行分类
        - name: Table2YAML
          val: |
            我要的不是YAML配置

            而是把上面那个table以YAML格式给我 code block

            格式类似

            - name: Rod
             性能: "更优（解码按需）"
             内存消耗: "更低"
             默认浏览器管理: "自动下载管理"
             并发处理: "无死锁（goob基础）"
             协议支持: "DevTools"
             配置灵活性: "高（可替换WS库）"
             架构稳定性: "稳定（版本绑定）"
             依赖项: "极少"
             跨浏览器支持: "仅Chromium"
             最佳适用场景: "自动化/爬虫"

            - name: Chromedp
             性能: "较低（全JSON解码）"
             内存消耗: "较高"
             默认浏览器管理: "依赖系统浏览器"
             并发处理: "高并发易死锁"
             协议支持: "DevTools"
             配置灵活性: "较低"
             架构稳定性: "版本冲突风险"
             依赖项: "较多（接口复杂）"
             跨浏览器支持: "仅Chromium"
             最佳适用场景: "简单Chrome操作"



            ---

            返回的 YAML code block需要注意以下事项：

            - 注意这个key只有一层（不要嵌套多层），且value均为字符串，注意字符串不要 ""
            - 如果value有多行或者多项的话，那么需要做成多行字符串。该字符串的每行都以- 开头（注意- 后面需要空格）
            - 以name为第一个key
            - 如果有url和doc的话，在name后面都加上相应的url以及doc。如果没有就不写url和doc了。
            - 除了name、url和doc（如果有的话），所有的key都需要中文（除非特别标识某个key需要英文）
        - name: TableCate
          val: |
            能否帮我对以上这些  repo 进行分类

            并且就该分类中选择最好、最主流、功能全面的repo，需要能够覆盖掉该分类其他repo的功能

            用table帮我列出来这些分类以及其中的repo，以及可被替代的repo


            按照5分制

            能否分别给这些repo打个分数（按照 是否主流、是否实用 这两个参数），只有一个综合得分，注意评分尽量均匀

            并且用table列出来，按照 score desc排序。如果评分<4，需要说明为啥不实用
        - name: TableVS
          val: |
            给我画个table进行对比，慎重选择对比项，告诉我为什么你做出这个判断

            你直接用 ✅、❌ 逐项对比并标记优劣
        - name: TechBreakdown
          val: |
            能否用几个标识性的技术来定义一下{cursor}?

            比如说 我会说

            LSM = AOF + 稀疏索引

            redis MSR = FYSNC + PSYNC + RESP buffer

            LRU = linked-list + HashMap

            LevelDB = SkipList（MemTable） + WAL（顺序写日志） + SSTable（分层有序文件） + Compaction（分层合并）

            我需要你用类似的方式来帮我定义一下


            都需要用类似 + 的形式来定义
        - name: ascii
          val: "你画个ascii图来说明这个过程吧"
        - name: conclusion
          val: |
            以下两个问题：


            1、能否给上面的整个chat history 做个总结？

            需要把上面我的提问，以及你的回答，按组各自做个总结


            注意这里的分组，指的是按照 一问一答 这样分组

            ---


            2、最后，再基于我们的讨论，给我一个对于相关问题的结论吧
        - name: git-msg
          val: "针对我当前修改代码，生成git commit msg，注意详略得当"
        - name: how-to-implement
          val: |
            感谢你给我提供的代码

            但是我对这个项目的代码一无所知

            你觉得我能从这个项目中学到什么？学到之后，可以自己实现这个项目？
        - name: kw
          val: |
            给我个简单的总结吧，两点：1、为啥tmux这种终端复用工具有用（why） 2、为啥应用zellij而非tmux

            两个问题各自提炼3个关键字。并各自用三句话扩充和解释这三个关键字。
        - name: mermaid
          val: |
            给我画个ascii图 以及 mermaid图

            注意直接给我两个图，后续不需要任何说明

            语法规范：
        - name: meta-qs
          val: "【元问题（第一性原理）】这个技术诞生的根本目的是什么？它解决了哪些其他技术无法解决的核心问题？"
        - name: yamlqs
          val: |
            好了，我已经大概了解该话题相关问题了。现在帮我就以上我们讨论的问题，整理并总结。

            给我提供yaml格式的吧

            格式类似

            ```
            - question # answer

            ```
        - name: qs
          val: |
            给我提供一些   相关问题，帮助我了解该领域，注意把相关问题分类，并且从易到难

            把问题和回答，做成yaml code block，其中问题是array，回答在各自问题后面，以注释形式提供

            格式类似

            ```yaml
                - q: question category 1
                  s:
                    - question 1 # answer for question 1
                    - question 2
                    - question 3
                    - ...
                - q: question category 2
            ```

        - name: repo
          val: "这个是啥？有啥用？怎么用？"

        - name: summary
          val: "帮我从这些文档中提取几个问题，并回答以及提取回答中的关键字（辅助我记忆）"
        - name: topics
          val: |
            ```yaml

              topics:
                - topic: topic1
                  des: 对topic的简单说明，或者说导读（对下面qs里问题的过渡）。比如说：1、为什么会产生该问题。2、该问题
                  qs:
                    - ... # comments
                    - ... # comments
                - topic: topic2
                  des: ...
                  qs:
                    - ... # comments
                    - ... # comments
            ```
        - name: validate
          val: "我上面的说法有问题吗？帮我做个勘误"

        - name: yes_or_no
          val: "以下说法正确吗？"

        - name: 技术类比
          val: |
            - 高可用：有很多备胎，即使失恋了，也可以迅速和别人谈恋爱
            - 注册中心：民政局
            - 负载均衡：和多个女朋友轮流约会
            - 熔断限流：
            - API 网关：相亲前的介绍人，双方无法直接联系，由介绍人代传
            - 雪崩：
            - 阻塞：
            - 同步和异步：同步就是一次只和一个女朋友约会，异步就是和多个女朋友约会
            - 异步线程不安全：一次和多个女朋友约会，很不安全
            - 分布式锁：同时和多个女朋友约会，要时间管理，否则会冲突
            - 分布式缓存：房间直接开一个月的，每次约会直接去，不需要每次都再开
            - 分布式消息队列：炮友，约就来，结束后主动离开，不约就不来
            - 分布式事务：离婚后很痛苦，希望没和她结过婚，没生孩子，一切回到婚前的样子，所以，分布式事务很难
            - 异地多活：出差到任何城市，都有炮友
            - 广播调用：同时向多个女朋友求婚，谁先答应就和谁结婚当镜像有更新时，会重新创建容器
        - name: 话术
          val: |
            **角色：** 你是一位精通商务沟通与公关话术的专家，尤其擅长在传达敏感信息、表达坚定立场的同时，维护或提升与对方的关系。你的话术以结构清晰、措辞专业、情商高超著称。

            **任务：** 根据用户提供的具体场景描述，生成一份高质量沟通话术草稿。

            **生成要求 (核心原则)：**
            1.  **目标驱动：** 明确用户的核心沟通目标（告知、立场声明、关系维护等），并围绕其构建话术。
            2.  **结构清晰：** 话术必须包含以下逻辑模块（可自然衔接，不必标注标题）：
                *   **礼节性开场：** 问候语，可包含时间歉意/感谢开启对话，营造友好氛围。
                *   **核心信息传递：** **清晰、准确、简洁**地传达用户需要告知的关键事实/结果/进展（如金额、时间、决定）。
                *   **立场/边界声明：** **坚定、明确**地表达用户不可更改的立场、事实或沟通边界（如"无法撤回"、"按协议执行"），避免含糊。
                *   **(可选) 沟通范围限定：** 明确说明本次沟通的目的（如"特此告知进展"），避免误解。
                *   **关系维护动作：** **必须包含高情商环节！** 根据场景选择最合适的策略：
                    *   **价值拔高/意义升华：** 强调对方在事件中的重要性、专业性、社会价值或独特贡献。
                    *   **具体感谢：** 真诚感谢对方的具体行动、配合或效率（务必具体化）。
                    *   **表达理解/共情：** 对可能给对方带来的不便或感受表示理解（适用于传递不利信息）。
                    *   **展望未来合作：** 表达对持续、积极关系的期待。
                *   **真诚致谢收尾：** 再次感谢，可呼应关系维护点或整体合作。
            3.  **措辞专业得体：** 语言符合商务/正式沟通场景，语气根据对象和情境调整（专业正式/专业亲和/坚定直接/真诚体谅）。
            4.  **平衡艺术：** 在传递信息（尤其是可能让对方不适的信息）和维护关系之间取得巧妙平衡。

            **用户输入格式：**
            请清晰描述以下信息（**尽可能具体**）：
            *   **【当前场景】：** 发生了什么？涉及谁？（例如：已与投诉客户和解需告知媒体，需向大客户解释因政策变动无法满足核心需求，需向监管机构汇报整改结果）
            *   **【沟通对象】：** 对方是谁？什么身份/关系？（例如：XX媒体记者，重要客户XX公司项目总监，XX监管局官员）
            *   **【核心目标】：** 你最想通过这次沟通达到什么？（例如：告知和解结果并强调素材已发不可撤回；解释无法满足需求的原因并维持客户关系；汇报整改并感谢监督）
            *   **【关键信息】：** **必须**传递哪些具体事实/数据/结果？（例如：和解金额20824.73元已到账；公司新政策规定X月X日起禁止Y操作；问题已按整改要求于X月X日完成）
            *   **【核心立场/边界】：** 哪些点是**必须明确告知且不可改变/协商**的？（例如：前期采访素材已制作完成无法撤回；合同条款X必须严格执行；退款申请已过时效期无法受理）
            *   **【风格/语气偏好】(可选)：** 希望话术整体感觉？（例如：专业正式、专业但亲和、坚定直接、真诚体谅）
            *   **【特别关系维护需求】(可选)：** 是否有特别想突出的点？（例如：重点强调媒体的监督价值；特别感谢客户长期支持；表达对监管指导的重视）

            **Output format：**
            1.  **生成的话术：** 一份完整的、可直接使用或微调的沟通文本。
            2.  **设计思路简述：** 用几句话说明：
                *   如何满足用户的核心目标和立场声明。
                *   采用了哪种关系维护策略及其原因。
                *   整体风格和措辞的考量。
            3.  **(可选) 风险提示/注意事项：** 基于场景，提示用户需要注意的潜在风险点或对方可能的反应（1-2点）。

            **现在，请告诉我您的具体场景和需求：**




tasks:
  default:
    desc: "Interactive snippet selector with fuzzy search"
    cmds:
      - |
        # Extract snippet names using yq
        snippet_names=$(yq eval '.vars.ss[].sub[].name' "{{.TASKFILE}}" | gum filter --placeholder "Select snippet..." {{.filter}})

        # Handle the selected snippet
        if [ -n "$snippet_names" ]; then
          # Extract the value of the selected snippet
          snippet_value=$(yq eval '.vars.ss[].sub[] | select(.name == "'"$snippet_names"'") | .val' "{{.TASKFILE}}")

          # Check if --no flag is present in CLI args
          if echo "{{.CLI_ARGS}}" | grep -q "\--no"; then
            # Just echo the snippet value
            echo "$snippet_value"
          else
            # Copy to clipboard (default behavior)
            echo -n "$snippet_value" | pbcopy 2>/dev/null || echo -n "$snippet_value" | xclip -selection clipboard 2>/dev/null || echo "Failed to copy to clipboard. Here's the content:\n$snippet_value"
            echo "Snippet content copied to clipboard"
          fi
        else
          echo "No snippet selected"
          exit 1
        fi
    vars:
      filter:
        sh: "echo ''"
    preconditions:
      - sh: command -v gum
        msg: gum not found, pls install
      - sh: command -v yq
        msg: yq not found, pls install
    interactive: true
    silent: true

  json:
    desc: "Output all snippets as JSON"
    cmds:
      - |
        # Output snippets in JSON format for programmatic use
        yq eval '.vars.ss' "{{.TASKFILE}}" -o json
    silent: true
