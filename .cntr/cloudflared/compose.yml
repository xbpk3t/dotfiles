---


services:
  cloudflared:
    image: cloudflare/cloudflared:latest
    container_name: cloudflared
    restart: unless-stopped
    command: tunnel run --token <YOUR_TUNNEL_TOKEN>
    # Alternatively, if using a named tunnel with a config file:
    # command: tunnel --config /etc/cloudflared/config.yaml run <YOUR_TUNNEL_NAME>
    volumes:
      - cloudflared-config:/etc/cloudflared # Mount a local directory for configuration if using a config file
    networks:
      - my_network

networks:
  my_network:
    external: true # Or define it as a bridge network if not already existing

volumes:
  cloudflared-config:


#{
#  config,
#  lib,
#  pkgs,
#  ...
#}: let
#  tunnelId = "8a3a09c5-3fa3-4488-ba53-541482b1427e";
#  credentialsFile = "/home/luck/.cloudflared/${tunnelId}.json";
#  cfg = config.services.cloudflared;
#  tunnelUnitName = "cloudflared-tunnel-${tunnelId}";
#in {
#  # https://mynixos.com/nixpkgs/options/services.cloudflared
#  services.cloudflared = {
#    enable = true;
#    package = pkgs.cloudflared;
#    tunnels.${tunnelId} = {
#      inherit credentialsFile;
#      originRequest = {
#        connectTimeout = "15s";
#        tlsTimeout = "10s";
#        tcpKeepAlive = "30s";
#        keepAliveConnections = 64;
#        noHappyEyeballs = true;
#      };
#      ingress = {
#        "alist.lucc.dev" = {
#          service = "http://127.0.0.1:5244";
#        };
#      };
#      default = "http_status:404";
#    };
#  };
#
#  systemd.services.${tunnelUnitName} = lib.mkIf cfg.enable (
#    let
#      tunnelCfg = cfg.tunnels.${tunnelId};
#      ingressList =
#        lib.mapAttrsToList (
#          hostname: rule:
#            if builtins.isString rule
#            then {
#              inherit hostname;
#              service = rule;
#            }
#            else
#              {
#                inherit hostname;
#              }
#              // rule
#        )
#        tunnelCfg.ingress;
#      warpRoutingCfg = lib.attrByPath ["warp-routing"] {} tunnelCfg;
#      originRequestCfg = lib.attrByPath ["originRequest"] {} tunnelCfg;
#      http2Config = {
#        tunnel = tunnelId;
#        "credentials-file" = "/run/credentials/${tunnelUnitName}.service/credentials.json";
#        protocol = "http2";
#        "edge-ip-version" = "4";
#        "ha-connections" = 2;
#        warp-routing = warpRoutingCfg;
#        originRequest = originRequestCfg;
#        ingress =
#          ingressList
#          ++ [
#            {
#              service = tunnelCfg.default;
#            }
#          ];
#      };
#      http2ConfigFile =
#        pkgs.writeText "cloudflared-${tunnelId}-http2.json" (builtins.toJSON http2Config);
#    in {
#      serviceConfig.ExecStart = lib.mkForce ''${cfg.package}/bin/cloudflared tunnel --config=${http2ConfigFile} --no-autoupdate run'';
#    }
#  );
#}
#{
#  config,
#  lib,
#  mylib,
#  ...
#}:
#with lib; let
#  cfg = config.modules.services.cloudflared;
#in {
#  options.modules.services.cloudflared = {
#    enable = mkEnableOption "Cloudflared tunnel client";
#
#    settings = mkOption {
#      type = types.attrs;
#      default = {};
#      example = {
#        package = "pkgs.cloudflared";
#        tunnels."example-tunnel" = {
#          credentialsFile = "/run/secrets/cloudflared.json";
#          default = "http_status:404";
#        };
#      };
#      description = "Pass-through options merged into services.cloudflared.* (except enable).";
#    };
#
#    ingress = mkOption {
#      type = types.nullOr (mylib.ingressOption "Cloudflared");
#      default = null;
#      description = "Expose Cloudflared-originated dashboards (e.g. Zero Trust UI) via the shared proxy.";
#    };
#  };
#
#  config = mkMerge [
#    (mkIf cfg.enable {
#      services.cloudflared = cfg.settings // {enable = true;};
#    })
#
#    (
#      mkIf (mylib.ingressEnabled cfg.ingress)
#      (mylib.mkReverseProxyIngress {
#        modulePath = "modules.services.cloudflared";
#        ingress = cfg.ingress;
#      })
#    )
#  ];
#}
